import * as recast from "recast";

import { Generator, GeneratorResult } from "./generator";

import { ParseNode } from "../grammar/helpers";
import { time } from "../perf-util";

export type VisitResult<T = unknown> = {
  node?: RecastAstNode;
  state?: T;
  stop?: boolean;
};

type RecastVisitor = (node: ParseNode, state: unknown, astStack: RecastAstNode[]) => VisitResult | null;
type InternalVisitResult = { result: VisitResult; state: unknown[]; ast: RecastAstNode[] };

export type RecastAstNode = recast.types.namedTypes.Node;

export abstract class RecastGenerator extends Generator {
  protected builder = recast.types.builders;
  protected program = this.builder.program([]);
  protected abstract readonly type: string;

  constructor(root: ParseNode) {
    super(root);
  }

  protected abstract getInitialState(): unknown;

  private attemptVisit(node: ParseNode, state: unknown[], ast: RecastAstNode[]): InternalVisitResult {
    const nodeName = node.name || node.tokenType?.name;
    let result: VisitResult = null;

    if (nodeName) {
      const func: RecastVisitor = this[nodeName];

      if (func) {
        const lastState = state.length === 0 ? null : state[state.length - 1];
        result = func.apply(this, [node, lastState, ...ast]);

        if (result?.node) {
          ast = [result.node, ...ast];
        }
        if (result?.state) {
          state = [result.state, ...state];
        }
      } else {
        // console.log(`No handler for ${nodeName}`);
      }
    }

    return {
      result,
      state,
      ast
    };
  }

  public async process(): Promise<GeneratorResult> {
    this.program.comments = [this.builder.commentLine(` @autogenerated Generated by ${this.constructor.name}`)];
    this.program.body = [];

    // Visit the root node explicitly
    // TODO: Not very clean to ignore children, but...
    const walkTimeHandle = time();

    type TreeStackNode = { node: ParseNode; state: unknown[]; ast: RecastAstNode[] };
    let ast: RecastAstNode[] = [this.program];
    let state: unknown[] = [];

    const rootResult = this.attemptVisit(this.root, state, ast);

    if (rootResult?.result?.node) {
      ast = [rootResult.result.node, ...ast];
    }

    if (rootResult?.result?.state) {
      state = [rootResult.result.stop, ...state];
    }

    if (!rootResult?.result?.stop) {
      const mapRootRule = (parseNode: ParseNode[]): TreeStackNode[] => {
        if (!parseNode) {
          return null;
        }

        return parseNode.map(i => ({ node: i, state, ast }));
      };

      // Ensure order of top level items, as the root rule is ordered by node name
      const treeStack: TreeStackNode[] = [
        ...mapRootRule(this.root.children.CommentsRule),
        ...mapRootRule(this.root.children.HeaderRule),
        ...mapRootRule(this.root.children.DefinitionRule),
        ...mapRootRule(this.root.children.PostCommentsRule)
      ].filter(Boolean);

      // Depth first walk of tree
      while (treeStack.length > 0) {
        // eslint-disable-next-line prefer-const
        let { node, state, ast } = treeStack.pop();

        const visit = this.attemptVisit(node, state, ast);
        ast = visit.ast;
        state = visit.state;

        if (!visit.result || !visit.result.stop) {
          const childKeys = node.children && Object.keys(node.children);
          const hasChildren = childKeys?.length;

          if (hasChildren) {
            // CstNode
            for (const key of childKeys) {
              const childNode: unknown[] = node.children[key];

              // NOTE: Children need to be reverse so when they enter the stack they are enumerated in the expected order
              const next = childNode.map(i => ({ node: i, state: [...state], ast: [...ast] })).reverse();

              treeStack.push(...next);
            }
          }
        }
      }
    }

    const walkTime = walkTimeHandle();
    const printTimeHandle = time();
    const output = recast.prettyPrint(this.program);
    const printTime = printTimeHandle();

    return {
      errors: [],
      warnings: [],
      content: [
        {
          type: this.type,
          content: output.code
        },
        {
          type: "map",
          content: output.map
        }
      ],
      timing: {
        print: printTime,
        walk: walkTime
      }
    };
  }

  protected id(name: string): recast.types.namedTypes.Identifier {
    return this.builder.identifier(name);
  }

  protected literal(value: string | number | boolean | RegExp): recast.types.namedTypes.Literal {
    return this.builder.literal(value);
  }
}
